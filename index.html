<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Mini Hoop Shot Detector ‚Äî ROI Motion + Blob Tracking</title>
  <style>
    :root{ --bg:#0b0e13; --ink:#e8eefc; --muted:#9fb0d5; --accent:#70e1ff; --ok:#45f0a0 }
    body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:960px;margin:0 auto;padding:14px;display:grid;gap:12px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.025));border:1px solid rgba(255,255,255,.08);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    header.card{padding:10px 12px;display:flex;align-items:center;justify-content:space-between}
    header h1{font-size:18px;margin:0}
    .video-area{position:relative;overflow:hidden;border-radius:14px}
    video{width:100%;height:auto;display:block;background:#000}
    canvas.overlay{position:absolute;inset:0;width:100%;height:100%;pointer-events:auto;touch-action:none;background:transparent}
    .controls{display:flex;flex-wrap:wrap;gap:10px;padding:10px;align-items:center}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button{appearance:none;border:1px solid rgba(255,255,255,.14);background:#1b2231;color:var(--ink);padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer}
    button.primary{background:linear-gradient(180deg,#2b7cff,#225de0)}
    button.danger{background:linear-gradient(180deg,#ff4d6d,#e03a58)}
    label{font-size:13px;color:var(--muted);display:inline-flex;gap:6px;align-items:center}
    input[type="range"]{width:120px}
    .pill{background:#0f1624;border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:999px}
    .toast{position:fixed;left:50%;top:16px;transform:translateX(-50%) translateY(-20px);opacity:0;background:#10161f;border:1px solid rgba(255,255,255,.14);padding:10px 14px;border-radius:12px;font-weight:800;transition:all .25s ease;z-index:20}
    .toast.show{transform:translateX(-50%) translateY(0);opacity:1}
    .status{position:fixed;bottom:10px;left:10px;right:10px;background:#10161f;border:1px solid rgba(255,255,255,.12);padding:8px 12px;border-radius:10px;color:var(--muted);font-size:12px;display:none;z-index:30}
    .status.show{display:block}
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card">
      <h1>Mini Hoop Shot Detector ‚Äî ROI Motion + Blob Tracking</h1>
      <span class="pill">Downward crossing ‚Ä¢ No color ‚Ä¢ No net</span>
    </header>

    <section class="video-area card">
      <video id="video" playsinline muted></video>
      <canvas class="overlay" id="overlay"></canvas>
    </section>

    <section class="card">
      <div class="controls">
        <div class="row">
          <button id="btnStart" class="primary">Start camera</button>
          <button id="btnCalib">Calibrate rim</button>
          <button id="btnEdit">Edit line</button>
          <button id="btnDetect">Start detection</button>
          <button id="btnStop" class="danger">Stop</button>
          <span class="pill">Baskets: <strong id="count">0</strong></span>
          <label>Debug <input type="checkbox" id="dbg" checked></label>
          <label>Show motion <input type="checkbox" id="showMotion" checked></label>
        </div>
        <div class="row">
          <label>Gate height <input type="range" id="gateH" min="80" max="240" value="130"></label>
          <label>Motion T <input type="range" id="motT" min="6" max="40" value="14"></label>
          <label>Min area <input type="range" id="minA" min="50" max="3000" value="120"></label>
          <label>Max area <input type="range" id="maxA" min="500" max="20000" value="6000"></label>
          <label>Min rim ratio <input type="range" id="minRR" min="10" max="60" value="28"></label>
          <label>Max rim ratio <input type="range" id="maxRR" min="70" max="120" value="95"></label>
        </div>
      </div>
    </section>

    <div class="toast" id="toast">Nice shot! üèÄ</div>
    <div class="status" id="status"></div>
  </div>

<script>
/* ---------- Elements ---------- */
const $ = s => document.querySelector(s);
const els = {
  video: $('#video'), overlay: $('#overlay'),
  btnStart: $('#btnStart'), btnCalib: $('#btnCalib'), btnEdit: $('#btnEdit'), btnDetect: $('#btnDetect'), btnStop: $('#btnStop'),
  gateH: $('#gateH'), motT: $('#motT'), minA: $('#minA'), maxA: $('#maxA'), minRR: $('#minRR'), maxRR: $('#maxRR'),
  dbg: $('#dbg'), showMotion: $('#showMotion'), toast: $('#toast'), status: $('#status'), count: $('#count')
};
const octx = els.overlay.getContext('2d');

/* ---------- State ---------- */
let stream=null, anim=null, running=false, detecting=false, editing=false, calibrating=false;
let rimLine=null; // {x1,y1,x2,y2}
let lastFire=0;
let history=[]; // {t, cy, above}

/* ---------- Utils ---------- */
function setStatus(msg){ els.status.textContent = msg; els.status.classList.add('show'); clearTimeout(setStatus._t); setStatus._t = setTimeout(()=> els.status.classList.remove('show'), 3500); }
function showToast(){ els.toast.classList.add('show'); setTimeout(()=> els.toast.classList.remove('show'), 1000); }
function speak(text){ try{ const u=new SpeechSynthesisUtterance(text); u.rate=1; speechSynthesis.cancel(); speechSynthesis.speak(u);}catch(e){} }

function yOnLine(x,{x1,y1,x2,y2}){ const dx=x2-x1; if(Math.abs(dx)<1e-4) return (y1+y2)/2; const m=(y2-y1)/dx; return y1 + (x-x1)*m; }

function draw(){ octx.clearRect(0,0,els.overlay.width,els.overlay.height); if(rimLine){ drawLine(rimLine); drawGate(rimLine); if(editing) drawHandles(rimLine); } }
function drawLine({x1,y1,x2,y2}){ octx.save(); octx.strokeStyle='#70e1ff'; octx.lineWidth=4; octx.setLineDash([8,6]); octx.beginPath(); octx.moveTo(x1,y1); octx.lineTo(x2,y2); octx.stroke(); octx.restore(); }
function drawHandles({x1,y1,x2,y2}){ drawHandle(x1,y1); drawHandle(x2,y2); }
function drawHandle(x,y){ octx.save(); octx.fillStyle='#70e1ff'; octx.strokeStyle='#03111f'; octx.lineWidth=2; octx.beginPath(); octx.arc(x,y,12,0,Math.PI*2); octx.fill(); octx.stroke(); octx.restore(); }
function drawGate(line){ const gh=+els.gateH.value; const {x1,y1,x2,y2}=line; const yTop=(y1+y2)/2; const x = Math.min(x1,x2)-8, w = Math.abs(x2-x1)+16, y = yTop, h = gh; octx.save(); octx.fillStyle='rgba(112,225,255,0.12)'; octx.strokeStyle='rgba(255,255,255,.6)'; octx.setLineDash([4,4]); octx.lineWidth=2; octx.fillRect(x,y,w,h); octx.strokeRect(x,y,w,h); octx.restore(); }

/* ---------- Gate ROI ---------- */
function gateROI(rim, gateH) {
  const pad = 8;
  const x = Math.min(rim.x1, rim.x2) - pad;
  const w = Math.abs(rim.x2 - rim.x1) + pad*2;
  const yTop = (rim.y1 + rim.y2) / 2;
  const h = gateH;
  return { x: Math.max(0, Math.floor(x)), y: Math.max(0, Math.floor(yTop)), w: Math.max(1, Math.floor(w)), h: Math.max(1, Math.floor(h)) };
}

/* ---------- Background model in ROI ---------- */
class ROIBackground {
  constructor() { this.w=0; this.h=0; this.buf=null; this.inited=false; }
  resize(w,h){ if(w!==this.w || h!==this.h){ this.w=w; this.h=h; this.buf=new Float32Array(w*h); this.buf.fill(0); this.inited=false; } }
  update(Y, alpha=0.04){ const N=this.w*this.h; if(!this.inited){ for(let i=0;i<N;i++) this.buf[i]=Y[i]; this.inited=true; return; } for(let i=0;i<N;i++) this.buf[i] = (1-alpha)*this.buf[i] + alpha*Y[i]; }
}
let roiBG = new ROIBackground();

/* ---------- Camera ---------- */
async function startCam(){ if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ setStatus('Camera API not available.'); return; } try{ stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ideal:'environment'} }, audio:false }); els.video.srcObject = stream; await els.video.play(); syncSize(); running=true; setStatus('Camera started'); loop(); }catch(e){ setStatus('Camera error: '+e.message); } }
function stopAll(){ detecting=false; running=false; editing=false; calibrating=false; if(anim) cancelAnimationFrame(anim); if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } setStatus('Stopped'); }
function syncSize(){ els.overlay.width = els.video.videoWidth||640; els.overlay.height = els.video.videoHeight||480; draw(); }
window.addEventListener('resize', ()=> setTimeout(syncSize,150));

/* ---------- Calibration & Editing ---------- */
function eventToCanvas(ev){ const rect=els.overlay.getBoundingClientRect(); const t=ev.touches?ev.touches[0]:ev; const x=(t.clientX-rect.left)*(els.overlay.width/rect.width); const y=(t.clientY-rect.top)*(els.overlay.height/rect.height); return {x,y}; }
function startCalibration(){ calibrating=true; editing=false; setStatus('Tap LEFT rim edge, then RIGHT rim edge'); let pts=[]; const commit=(ev)=>{ ev.preventDefault(); const p=eventToCanvas(ev); pts.push(p); octx.save(); octx.fillStyle='#ffd166'; octx.beginPath(); octx.arc(p.x,p.y,6,0,Math.PI*2); octx.fill(); octx.restore(); if(pts.length===2){ els.overlay.removeEventListener('touchstart', commit); els.overlay.removeEventListener('click', commit); rimLine={x1:pts[0].x,y1:pts[0].y,x2:pts[1].x,y2:pts[1].y}; calibrating=false; editing=true; draw(); setStatus('Rim set. Use Edit to fine tune.'); } }; els.overlay.addEventListener('touchstart', commit, {passive:false}); els.overlay.addEventListener('click', commit, {passive:false}); }
let dragging=null; // 'p1'|'p2'
els.overlay.addEventListener('touchstart', (ev)=>{ if(!editing||!rimLine) return; const p=eventToCanvas(ev); const d1=Math.hypot(p.x-rimLine.x1,p.y-rimLine.y1), d2=Math.hypot(p.x-rimLine.x2,p.y-rimLine.y2); const hs=22; dragging = d1<=hs ? 'p1' : (d2<=hs ? 'p2' : null); }, {passive:false});
els.overlay.addEventListener('mousedown', (ev)=>{ if(!editing||!rimLine) return; const p=eventToCanvas(ev); const d1=Math.hypot(p.x-rimLine.x1,p.y-rimLine.y1), d2=Math.hypot(p.x-rimLine.x2,p.y-rimLine.y2); const hs=22; dragging = d1<=hs ? 'p1' : (d2<=hs ? 'p2' : null); });
els.overlay.addEventListener('touchmove', (ev)=>{ if(!dragging) return; ev.preventDefault(); const p=eventToCanvas(ev); if(dragging==='p1'){ rimLine.x1=p.x; rimLine.y1=p.y; } else { rimLine.x2=p.x; rimLine.y2=p.y; } draw(); }, {passive:false});
els.overlay.addEventListener('mousemove', (ev)=>{ if(!dragging) return; const p=eventToCanvas(ev); if(dragging==='p1'){ rimLine.x1=p.x; rimLine.y1=p.y; } else { rimLine.x2=p.x; rimLine.y2=p.y; } draw(); });
window.addEventListener('touchend', ()=> dragging=null);
window.addEventListener('mouseup', ()=> dragging=null);

/* ---------- Connected Components ---------- */
function labelBlobs(mask, w, h) {
  const visited = new Uint8Array(w*h);
  const blobs = [];
  const stackX = new Int32Array(w*h);
  const stackY = new Int32Array(w*h);
  const idx = (x,y)=> y*w + x;
  for (let y=0; y<h; y++) {
    for (let x=0; x<w; x++) {
      const i = idx(x,y);
      if (!mask[i] || visited[i]) continue;
      let top = 0;
      stackX[top] = x; stackY[top] = y; top++;
      visited[i] = 1;
      let minX=x, maxX=x, minY=y, maxY=y;
      let area = 0, sumX=0, sumY=0;
      while (top>0) {
        top--;
        const cx = stackX[top], cy = stackY[top];
        const ci = idx(cx,cy);
        area++; sumX += cx; sumY += cy;
        if (cx<minX) minX=cx; if (cx>maxX) maxX=cx;
        if (cy<minY) minY=cy; if (cy>maxY) maxY=cy;
        // 4-connected neighbors
        if (cx>0)   { const ni=ci-1;      if (mask[ni] && !visited[ni]) { visited[ni]=1; stackX[top]=cx-1; stackY[top]=cy; top++; } }
        if (cx<w-1) { const ni=ci+1;      if (mask[ni] && !visited[ni]) { visited[ni]=1; stackX[top]=cx+1; stackY[top]=cy; top++; } }
        if (cy>0)   { const ni=ci-w;      if (mask[ni] && !visited[ni]) { visited[ni]=1; stackX[top]=cx;   stackY[top]=cy-1; top++; } }
        if (cy<h-1) { const ni=ci+w;      if (mask[ni] && !visited[ni]) { visited[ni]=1; stackX[top]=cx;   stackY[top]=cy+1; top++; } }
      }
      const bboxW = maxX-minX+1, bboxH = maxY-minY+1;
      const cx = sumX/area, cy = sumY/area;
      const solidity = area / (bboxW * bboxH);
      blobs.push({ area, minX, minY, maxX, maxY, bboxW, bboxH, cx, cy, solidity });
    }
  }
  return blobs;
}

/* ---------- Detection loop (ROI + background + blob pick) ---------- */
function loop(){
  if(!running) return;
  anim = requestAnimationFrame(loop);
  draw();
  if(!detecting || !rimLine) return;

  const gh = +els.gateH.value;
  const roi = gateROI(rimLine, gh);

  // ROI canvas 1:1
  if(!loop.roiCanvas){
    loop.roiCanvas = document.createElement('canvas');
    loop.roiCtx = loop.roiCanvas.getContext('2d', { willReadFrequently: true });
  }
  loop.roiCanvas.width = roi.w;
  loop.roiCanvas.height = roi.h;
  loop.roiCtx.drawImage(els.video, roi.x, roi.y, roi.w, roi.h, 0, 0, roi.w, roi.h);

  const img = loop.roiCtx.getImageData(0, 0, roi.w, roi.h);
  const d = img.data;
  const N = roi.w * roi.h;

  // 1) Luminance buffer
  const Y = new Float32Array(N);
  for (let i=0, j=0; i<d.length; i+=4, j++){
    const r=d[i], g=d[i+1], b=d[i+2];
    Y[j] = 0.299*r + 0.587*g + 0.114*b;
  }

  // 2) Update background
  roiBG.resize(roi.w, roi.h);
  roiBG.update(Y, 0.04);

  // 3) Motion mask
  const MOTION_T = +els.motT.value;
  const mask = new Uint8Array(N);
  for (let y=0, k=0; y<roi.h; y++) {
    for (let x=0; x<roi.w; x++, k++) {
      const diff = Math.abs(Y[k] - roiBG.buf[k]);
      if (diff > MOTION_T) mask[k] = 1;
    }
  }

  // Optional: show raw motion pixels
  if (els.dbg.checked && els.showMotion.checked) {
    for (let y=0, k=0; y<roi.h; y++) {
      for (let x=0; x<roi.w; x++, k++) {
        if (mask[k]) {
          octx.fillStyle='rgba(255,80,80,0.85)';
          octx.fillRect(roi.x + x, roi.y + y, 1.2, 1.2);
        }
      }
    }
  }

  // 4) Connected components -> choose best blob
  const blobs = labelBlobs(mask, roi.w, roi.h);
  if (!blobs.length) return;

  const rimWidthPx = Math.hypot(rimLine.x2 - rimLine.x1, rimLine.y2 - rimLine.y1);
  const minRimRatio = (+els.minRR.value)/100, maxRimRatio = (+els.maxRR.value)/100;
  const MIN_AREA = +els.minA.value, MAX_AREA = +els.maxA.value;

  let best=null, bestScore=-1;
  for (const b of blobs) {
    const { area, bboxW, bboxH, solidity } = b;
    const aspect = bboxW / Math.max(1, bboxH);
    const widthOK = bboxW >= rimWidthPx*minRimRatio && bboxW <= rimWidthPx*maxRimRatio;
    const aspectOK = aspect > 0.6 && aspect < 1.6;
    const solidityOK = solidity > 0.35 && solidity < 0.95;
    const areaOK = area >= MIN_AREA && area <= MAX_AREA;
    if (!(widthOK && aspectOK && solidityOK && areaOK)) continue;
    const compact = 1 - Math.abs(solidity - 0.7); // prefer near-compact blobs
    const score = area * compact;
    if (score > bestScore) { bestScore = score; best = b; }
  }
  if (!best) return;

  // 5) Chosen blob visuals
  const cx = roi.x + best.cx;
  const cy = roi.y + best.cy;
  if (els.dbg.checked) {
    octx.save();
    octx.strokeStyle='rgba(0,255,0,0.6)'; octx.strokeRect(roi.x, roi.y, roi.w, roi.h);
    octx.strokeStyle='rgba(80,200,255,0.9)'; octx.strokeRect(roi.x+best.minX, roi.y+best.minY, best.bboxW, best.bboxH);
    octx.fillStyle='#45f0a0'; octx.beginPath(); octx.arc(cx,cy,6,0,Math.PI*2); octx.fill();
    octx.restore();
  }

  // 6) Downward crossing vs rim line
  const yLineAtCx = yOnLine(cx, rimLine);
  const above = cy < yLineAtCx;
  const now = performance.now();
  history.push({t:now, cy, above});
  while (history.length && now - history[0].t > 700) history.shift();

  const wasAbove = history.some(h => h.above);
  const isBelow  = !above;
  const first = history[0], last = history[history.length-1];
  const downward = (last && first) ? (last.cy - first.cy) > 18 : false;

  if (wasAbove && isBelow && downward && (now - lastFire > 1200)) {
    lastFire = now;
    els.count.textContent = String((parseInt(els.count.textContent||'0',10))+1);
    showToast(); speak('Nice shot'); history.length = 0;
  }
}

/* ---------- UI wiring ---------- */
els.btnStart.addEventListener('click', startCam);
els.btnStop.addEventListener('click', stopAll);
els.btnCalib.addEventListener('click', startCalibration);
els.btnEdit.addEventListener('click', ()=>{ if(!rimLine){ alert('Calibrate first.'); return; } editing=!editing; draw(); setStatus(editing?'Editing: drag endpoints':''); });
els.btnDetect.addEventListener('click', ()=>{ if(!rimLine){ alert('Calibrate first.'); return; } detecting=true; editing=false; setStatus('Detecting‚Ä¶'); });

/* ---------- Init ---------- */
window.addEventListener('load', ()=> setStatus('Load complete. Start camera ‚Üí Calibrate rim ‚Üí Start detection.'));
</script>
</body>
</html>
