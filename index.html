<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Mini Hoop Shot Detector ‚Äî Stable Mode</title>
  <style>
    :root{ --bg:#0b0e13; --ink:#e8eefc; --muted:#9fb0d5; --accent:#70e1ff; --ok:#45f0a0; --warn:#ffd166; --err:#ff6b6b }
    body{margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
    .wrap{max-width:960px; margin:0 auto; padding:14px; display:grid; gap:12px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.025)); border:1px solid rgba(255,255,255,.08); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    header.card{padding:10px 12px; display:flex; align-items:center; justify-content:space-between}
    header h1{font-size:18px; margin:0}

    .video-area{ position:relative; overflow:hidden; border-radius:14px }
    video{ width:100%; height:auto; display:block; background:#000 }
    canvas.overlay{ position:absolute; inset:0; width:100%; height:100%; pointer-events:auto; touch-action:none; background:transparent }

    .controls{display:flex; flex-wrap:wrap; gap:10px; padding:10px; align-items:center}
    .row{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
    button{appearance:none; border:1px solid rgba(255,255,255,.14); background:#1b2231; color:var(--ink); padding:8px 12px; border-radius:10px; font-weight:700; cursor:pointer}
    button.primary{background:linear-gradient(180deg, #2b7cff, #225de0)}
    button.danger{background:linear-gradient(180deg, #ff4d6d, #e03a58)}
    label{font-size:13px; color:var(--muted); display:inline-flex; gap:6px; align-items:center}
    input[type="range"]{ width:120px }

    .toast{position:fixed; left:50%; top:16px; transform:translateX(-50%) translateY(-20px); opacity:0; background:#10161f; border:1px solid rgba(255,255,255,.14); padding:10px 14px; border-radius:12px; font-weight:800; transition:all .25s ease; z-index:20}
    .toast.show{transform:translateX(-50%) translateY(0); opacity:1}

    .status{position:fixed; bottom:10px; left:10px; right:10px; background:#10161f; border:1px solid rgba(255,255,255,.12); padding:8px 12px; border-radius:10px; color:var(--muted); font-size:12px; display:none; z-index:30}
    .status.show{display:block}

    .nudge{display:inline-grid; grid-template-columns:40px 40px 40px; grid-template-rows:40px 40px 40px; gap:4px}
    .nudge button{width:40px; height:40px; font-size:16px; border-radius:8px}
    .nudge .empty{opacity:0}
    .pill{background:#0f1624; border:1px solid rgba(255,255,255,.12); padding:6px 10px; border-radius:999px}
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card"><h1>Mini Hoop Shot Detector ‚Äî Stable Mode</h1><span class="pill">No color filter ‚Ä¢ iPhone‚Äëfriendly</span></header>

    <section class="video-area card" id="videoArea">
      <video id="video" playsinline muted></video>
      <canvas class="overlay" id="overlay"></canvas>
    </section>

    <section class="card">
      <div class="controls">
        <div class="row">
          <button id="btnStart" class="primary">Start camera</button>
          <button id="btnCalib">Calibrate</button>
          <button id="btnEdit">Edit line</button>
          <button id="btnDetect">Start detection</button>
          <button id="btnStop" class="danger">Stop</button>
          <span class="pill">Baskets: <strong id="count">0</strong></span>
        </div>
        <div class="row">
          <label>Gate height <input type="range" id="gateH" min="60" max="220" value="110"></label>
          <label>Min area <input type="range" id="minArea" min="40" max="800" value="120"></label>
          <label>Max area <input type="range" id="maxArea" min="300" max="4000" value="2400"></label>
          <label>Net sensitivity <input type="range" id="netThresh" min="40" max="1200" value="220"></label>
          <span class="pill">Preset: 
            <button id="presetLoose">Loose</button>
            <button id="presetBalanced">Balanced</button>
            <button id="presetStrict">Strict</button>
          </span>
        </div>
        <div class="row">
          <span class="pill">Adjust endpoints (precise)</span>
          <label><input type="radio" name="which" id="p1" checked> P1</label>
          <label><input type="radio" name="which" id="p2"> P2</label>
          <label>Step <input type="range" id="step" min="1" max="8" value="2"></label>
          <div class="nudge">
            <span class="empty"></span><button id="nUp">‚Üë</button><span class="empty"></span>
            <button id="nLeft">‚Üê</button><span class="empty"></span><button id="nRight">‚Üí</button>
            <span class="empty"></span><button id="nDown">‚Üì</button><span class="empty"></span>
          </div>
        </div>
      </div>
    </section>

    <div class="toast" id="toast">Nice shot! üèÄ</div>
    <div class="status" id="status"></div>
  </div>

<script>
// ==== ELEMENTS ====
const els = {
  video: document.getElementById('video'), overlay: document.getElementById('overlay'),
  btnStart: document.getElementById('btnStart'), btnCalib: document.getElementById('btnCalib'), btnEdit: document.getElementById('btnEdit'), btnDetect: document.getElementById('btnDetect'), btnStop: document.getElementById('btnStop'),
  gateH: document.getElementById('gateH'), minArea: document.getElementById('minArea'), maxArea: document.getElementById('maxArea'), netThresh: document.getElementById('netThresh'),
  presetLoose: document.getElementById('presetLoose'), presetBalanced: document.getElementById('presetBalanced'), presetStrict: document.getElementById('presetStrict'),
  p1: document.getElementById('p1'), p2: document.getElementById('p2'), step: document.getElementById('step'), nUp: document.getElementById('nUp'), nDown: document.getElementById('nDown'), nLeft: document.getElementById('nLeft'), nRight: document.getElementById('nRight'),
  toast: document.getElementById('toast'), status: document.getElementById('status'), count: document.getElementById('count')
};
const octx = els.overlay.getContext('2d');

let stream=null, anim=null, running=false, detecting=false, editing=false, calibrating=false;
let rimLine=null; // {x1,y1,x2,y2}
let DIFF_THRESH = 26; // mutable now
const work = document.createElement('canvas');
const wctx = work.getContext('2d',{willReadFrequently:true});
let history=[];

function setStatus(msg){ els.status.textContent = msg; els.status.classList.add('show'); clearTimeout(setStatus._t); setStatus._t = setTimeout(()=> els.status.classList.remove('show'), 3500); }
function showToast(){ els.toast.classList.add('show'); setTimeout(()=> els.toast.classList.remove('show'), 1000); }
function speak(text){ try{ const u=new SpeechSynthesisUtterance(text); u.rate=1; speechSynthesis.cancel(); speechSynthesis.speak(u);}catch(e){} }

// ==== CAMERA ====
async function startCam(){
  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ setStatus('Camera API not available.'); return; }
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ideal:'environment'} }, audio:false });
    els.video.srcObject=stream; await els.video.play(); syncSize(); running=true; setStatus('Camera started'); loop();
  }catch(e){ setStatus('Camera error: '+e.message); }
}
function stopAll(){ detecting=false; running=false; editing=false; calibrating=false; if(anim) cancelAnimationFrame(anim); if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } setStatus('Stopped'); }
function syncSize(){ els.overlay.width = els.video.videoWidth||640; els.overlay.height=els.video.videoHeight||480; work.width=Math.round(els.overlay.width*0.45); work.height=Math.round(els.overlay.height*0.45); draw(); }
window.addEventListener('resize', ()=> setTimeout(syncSize,150));

// ==== DRAWING ====
function draw(){ octx.clearRect(0,0,els.overlay.width,els.overlay.height); if(rimLine){ drawLine(rimLine); drawGate(rimLine); if(editing) drawHandles(rimLine); } }
function drawLine({x1,y1,x2,y2}){ octx.save(); octx.strokeStyle='#70e1ff'; octx.lineWidth=4; octx.setLineDash([8,6]); octx.beginPath(); octx.moveTo(x1,y1); octx.lineTo(x2,y2); octx.stroke(); octx.restore(); }
function drawHandles({x1,y1,x2,y2}){ drawHandle(x1,y1); drawHandle(x2,y2); }
function drawHandle(x,y){ octx.save(); octx.fillStyle='#70e1ff'; octx.strokeStyle='#03111f'; octx.lineWidth=2; octx.beginPath(); octx.arc(x,y,12,0,Math.PI*2); octx.fill(); octx.stroke(); octx.restore(); }
function yOnLine(x,{x1,y1,x2,y2}){ const dx=x2-x1; if(Math.abs(dx)<1e-4) return (y1+y2)/2; const m=(y2-y1)/dx; return y1 + (x-x1)*m; }
function drawGate(line){ const gh=+els.gateH.value; const {x1,y1,x2,y2}=line; const y1b=y1+gh, y2b=y2+gh; octx.save(); octx.strokeStyle='rgba(255,255,255,.6)'; octx.setLineDash([4,4]); octx.lineWidth=2; octx.beginPath(); octx.moveTo(x1,y1); octx.lineTo(x2,y2); octx.lineTo(x2,y2b); octx.lineTo(x1,y1b); octx.closePath(); octx.stroke(); octx.restore(); }

// ==== LOOP ====
function loop(){ if(!running) return; anim=requestAnimationFrame(loop); draw(); if(!detecting || !rimLine) return;
  wctx.drawImage(els.video,0,0,work.width,work.height); const curr=wctx.getImageData(0,0,work.width,work.height); if(!loop.prev){ loop.prev=curr; return; } const prev=loop.prev; const dc=curr.data, dp=prev.data; const w=work.width, h=work.height;
  let movedGate=0,sumGX=0,sumGY=0, movedNet=0;
  const gh=+els.gateH.value, minA=+els.minArea.value, maxA=+els.maxArea.value;
  for(let i=0;i<dc.length;i+=4){ const dr=dc[i]-dp[i], dg=dc[i+1]-dp[i+1], db=dc[i+2]-dp[i+2]; const diff=Math.abs(dr)+Math.abs(dg)+Math.abs(db); if(diff>DIFF_THRESH){ const idx=i/4; const x=idx%w; const y=(idx-x)/w; const sx=x*(els.overlay.width/w), sy=y*(els.overlay.height/h); const yTop=yOnLine(sx,rimLine), yBot=yTop+gh; const insideX = sx>=Math.min(rimLine.x1,rimLine.x2)-8 && sx<=Math.max(rimLine.x1,rimLine.x2)+8; if(insideX && sy>=yTop && sy<=yBot){ movedGate++; sumGX+=x; sumGY+=y; } else if(insideX && sy>yBot && sy<=yBot+gh*0.7){ movedNet++; } } }
  loop.prev=curr;
  if(movedGate>=minA && movedGate<=maxA){ const scaleX=els.overlay.width/w, scaleY=els.overlay.height/h; const cx=(sumGX/movedGate)*scaleX, cy=(sumGY/movedGate)*scaleY; octx.save(); octx.fillStyle='#45f0a0'; octx.beginPath(); octx.arc(cx,cy,8,0,Math.PI*2); octx.fill(); octx.restore();
    const now=performance.now(); const yLine=yOnLine(cx,rimLine); const above=cy<yLine; history.push({t:now,cx,cy,above,net:movedNet}); while(history.length && now-history[0].t>900) history.shift();
    const wasAbove = history.some(h=>h.above); const isBelow = !above; const first=history[0], last=history[history.length-1]; const downward = (last && first) ? (last.cy-first.cy)>18 : false; const netSum = history.filter(h=> now-h.t<260).reduce((a,b)=>a+b.net,0); const netOK = netSum > +els.netThresh.value; if(wasAbove && isBelow && downward && netOK){ if(!loop.lastFire || now-loop.lastFire>1100){ loop.lastFire=now; els.count.textContent = String(parseInt(els.count.textContent||'0',10)+1); showToast(); speak('Nice shot'); history.length=0; } }
  }
}

// ==== CALIBRATION (TWO commits; no finger offset; simple & reliable) ====
function startCalibration(){ calibrating=true; editing=false; setStatus('Tap LEFT rim edge, then RIGHT rim edge'); let points=[]; const commit=(ev)=>{ ev.preventDefault(); const p=eventToCanvas(ev); points.push(p); // marker
    octx.save(); octx.fillStyle='#ffd166'; octx.beginPath(); octx.arc(p.x,p.y,6,0,Math.PI*2); octx.fill(); octx.restore();
    if(points.length===2){ els.overlay.removeEventListener('touchstart', commit); els.overlay.removeEventListener('click', commit); rimLine={x1:points[0].x,y1:points[0].y,x2:points[1].x,y2:points[1].y}; calibrating=false; editing=true; draw(); setStatus('Line set. Use nudge controls for precision.'); }
  };
  els.overlay.addEventListener('touchstart', commit, {passive:false}); els.overlay.addEventListener('click', commit, {passive:false}); }
function eventToCanvas(ev){ const rect=els.overlay.getBoundingClientRect(); const t=ev.touches?ev.touches[0]:ev; const x=(t.clientX-rect.left)*(els.overlay.width/rect.width); const y=(t.clientY-rect.top)*(els.overlay.height/rect.height); return {x,y}; }

// ==== EDITING (drag OR precise nudges) ====
let dragging=null; // 'p1'|'p2'
els.overlay.addEventListener('touchstart', (ev)=>{ if(!editing || !rimLine) return; const p=eventToCanvas(ev); const d1=Math.hypot(p.x-rimLine.x1,p.y-rimLine.y1), d2=Math.hypot(p.x-rimLine.x2,p.y-rimLine.y2); const hs=22; if(d1<=hs){ dragging='p1'; } else if(d2<=hs){ dragging='p2'; } }, {passive:false});
els.overlay.addEventListener('mousedown', (ev)=>{ if(!editing || !rimLine) return; const p=eventToCanvas(ev); const d1=Math.hypot(p.x-rimLine.x1,p.y-rimLine.y1), d2=Math.hypot(p.x-rimLine.x2,p.y-rimLine.y2); const hs=22; if(d1<=hs){ dragging='p1'; } else if(d2<=hs){ dragging='p2'; } });
els.overlay.addEventListener('touchmove', (ev)=>{ if(!dragging) return; ev.preventDefault(); const p=eventToCanvas(ev); if(dragging==='p1'){ rimLine.x1=p.x; rimLine.y1=p.y; } else { rimLine.x2=p.x; rimLine.y2=p.y; } draw(); }, {passive:false});
els.overlay.addEventListener('mousemove', (ev)=>{ if(!dragging) return; const p=eventToCanvas(ev); if(dragging==='p1'){ rimLine.x1=p.x; rimLine.y1=p.y; } else { rimLine.x2=p.x; rimLine.y2=p.y; } draw(); });
window.addEventListener('touchend', ()=> dragging=null); window.addEventListener('mouseup', ()=> dragging=null);

// Nudge controls
function nudge(dx,dy){ if(!rimLine) return; const step=+els.step.value; const which=els.p1.checked?'p1':'p2'; const key=which==='p1'?['x1','y1']:['x2','y2']; rimLine[key[0]]+=dx*step; rimLine[key[1]]+=dy*step; draw(); }
els.nUp.addEventListener('click', ()=> nudge(0,-1)); els.nDown.addEventListener('click', ()=> nudge(0,1)); els.nLeft.addEventListener('click', ()=> nudge(-1,0)); els.nRight.addEventListener('click', ()=> nudge(1,0));

// Presets (no color filter; green ball friendly)
els.presetLoose.addEventListener('click', ()=>{ DIFF_THRESH=22; els.gateH.value=130; els.minArea.value=90; els.maxArea.value=2800; els.netThresh.value=160; setStatus('Preset: Loose'); });
els.presetBalanced.addEventListener('click', ()=>{ DIFF_THRESH=26; els.gateH.value=110; els.minArea.value=120; els.maxArea.value=2400; els.netThresh.value=220; setStatus('Preset: Balanced'); });
els.presetStrict.addEventListener('click', ()=>{ DIFF_THRESH=30; els.gateH.value=90; els.minArea.value=160; els.maxArea.value=2000; els.netThresh.value=300; setStatus('Preset: Strict'); });

// ==== UI wiring ====
els.btnStart.addEventListener('click', startCam);
els.btnStop.addEventListener('click', stopAll);
els.btnCalib.addEventListener('click', startCalibration);
els.btnEdit.addEventListener('click', ()=>{ if(!rimLine){ alert('Calibrate first.'); return; } editing=!editing; draw(); setStatus(editing?'Editing: drag or nudge endpoints':''); });
els.btnDetect.addEventListener('click', ()=>{ if(!rimLine){ alert('Calibrate first.'); return; } detecting=true; editing=false; setStatus('Detecting‚Ä¶'); });
</script>
</body>
</html>
