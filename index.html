<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Mini Hoop Shot Detector</title>
  <style>
    :root{
      --bg:#0b0e13; --panel:#121722; --ink:#e8eefc; --muted:#9fb0d5; --accent:#70e1ff; --ok:#45f0a0; --warn:#ffd166; --err:#ff6b6b;
    }
    html,body{height:100%;}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:radial-gradient(1200px 800px at 70% -10%, #1a2030 0%, var(--bg) 60%); color:var(--ink);}
    .wrap{display:grid; grid-template-columns:1fr; gap:14px; padding:16px; max-width:960px; margin:0 auto;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.08); border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.35);}
    header.card{padding:16px 18px; display:flex; align-items:center; justify-content:space-between;}
    header h1{font-size:18px; margin:0; letter-spacing:.2px}
    header .badge{font-size:12px; color:var(--bg); background:var(--accent); padding:4px 8px; border-radius:999px; font-weight:700}

    .video-area{position:relative; overflow:hidden; border-radius:18px}
    video{width:100%; display:block; background:#000}
    canvas.overlay{$1pointer-events:auto$2}

    .controls{display:flex; flex-wrap:wrap; gap:10px; padding:12px; align-items:center}
    button{appearance:none; border:1px solid rgba(255,255,255,.14); background:#1b2231; color:var(--ink); padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer; transition:transform .05s ease, background .2s ease, border .2s ease}
    button:hover{background:#1f283b}
    button:active{transform:translateY(1px)}
    button.primary{background:linear-gradient(180deg, #2b7cff, #225de0); border-color:rgba(255,255,255,.18)}
    button.danger{background:linear-gradient(180deg, #ff4d6d, #e03a58)}
    .stats{margin-left:auto; display:flex; gap:16px; align-items:center; font-size:14px; color:var(--muted)}
    .dot{width:8px; height:8px; border-radius:50%; display:inline-block; margin-right:6px}
    .dot.live{background:var(--ok); box-shadow:0 0 10px var(--ok)}
    .dot.idle{background:#56607a}

    .pill{background:#151c2b; border:1px solid rgba(255,255,255,.1); padding:6px 10px; border-radius:999px}

    .toast{position:fixed; left:50%; top:16px; transform:translateX(-50%) translateY(-20px); opacity:0; background:#10161f; border:1px solid rgba(255,255,255,.14); padding:12px 16px; border-radius:14px; font-weight:700; letter-spacing:.3px; box-shadow:0 10px 40px rgba(0,0,0,.45); transition:all .35s ease; z-index:10}
    .toast.show{transform:translateX(-50%) translateY(0); opacity:1}
    .counter{font-size:28px; font-weight:800}

    .help{padding:12px 16px; color:var(--muted); font-size:14px; line-height:1.5}
    .help ol{margin:8px 0 0 18px}

    .calib-overlay{position:absolute; inset:0; display:none; align-items:center; justify-content:center; backdrop-filter:blur(0px); pointer-events:none}
    .calib-overlay.active{display:flex}
    .calib-msg{background:#0f1520cc; border:1px solid rgba(255,255,255,.18); padding:14px 16px; border-radius:12px; font-weight:600}

    .footer{padding:10px 14px; color:var(--muted); font-size:12px; text-align:center}
    a{color:#8fd1ff}
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card">
      <h1>Mini Hoop Shot Detector</h1>
      <span class="badge">Prototype</span>
    </header>

    <section class="video-area card" id="videoCard">
      <video id="video" playsinline muted></video>
      <canvas class="overlay" id="overlay"></canvas>
      <div class="calib-overlay" id="calibOverlay">
        <div class="calib-msg">Tap two points across the rim to set the detection line</div>
      </div>
    </section>

    <section class="card">
      <div class="controls">
        <button id="btnStart" class="primary">Start camera</button>
        <button id="btnCalib">Calibrate rim line</button>
        <button id="btnDetect" disabled>Start detection</button>
        <button id="btnStop" class="danger" disabled>Stop</button>
        <div class="stats">
          <span class="pill"><span id="liveDot" class="dot idle"></span><span id="liveText">Idle</span></span>
          <span class="pill">FPS: <span id="fps">0</span></span>
          <span class="pill">Motion: <span id="motion">0</span></span>
          <span class="pill">Baskets: <span class="counter" id="count">0</span></span>
        </div>
      </div>
    </section>

    <section class="help card">
      <strong>How to use</strong>
      <ol>
        <li>Place your phone/tablet so the hoop is clearly visible. Lighting helps.</li>
        <li>Tap <em>Start camera</em>. If asked, choose the back camera.</li>
        <li>Tap <em>Calibrate rim line</em> and tap two points across the rim (left & right).</li>
        <li>Tap <em>Start detection</em>. When a moving object (the ball) passes downward through the line, you'll hear ‚ÄúNice shot!‚Äù and the counter increases.</li>
      </ol>
      <div style="margin-top:6px">Tip: Keep the hoop mostly still in frame. This simple model uses motion crossing the rim line (no ML yet). Avoid people walking behind the hoop.</div>
    </section>

    <div class="toast" id="toast">Nice shot! üèÄ</div>
    <footer class="footer">Future: hook into smart lights (Hue, Home Assistant) when a basket is detected.</footer>
  </div>

  <script>
    const els = {
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
      btnStart: document.getElementById('btnStart'),
      btnCalib: document.getElementById('btnCalib'),
      btnDetect: document.getElementById('btnDetect'),
      btnStop: document.getElementById('btnStop'),
      fps: document.getElementById('fps'),
      motion: document.getElementById('motion'),
      count: document.getElementById('count'),
      toast: document.getElementById('toast'),
      liveDot: document.getElementById('liveDot'),
      liveText: document.getElementById('liveText'),
      videoCard: document.getElementById('videoCard'),
      calibOverlay: document.getElementById('calibOverlay'),
    };

    let stream = null;
    let anim = null;
    let running = false;
    let detecting = false;
    let lastTime = performance.now();
    let frames = 0, fpsAvg = 0;

    // Working canvases
    const work = document.createElement('canvas');
    const wctx = work.getContext('2d', { willReadFrequently: true });
    const octx = els.overlay.getContext('2d');

    // Downscale factor for processing speed
    const SCALE = 0.4; // 40% of video size for motion analysis
    const THRESH = 28; // motion threshold (0-255)
    const MIN_AREA = 260; // min moving pixels to consider an object

    // Calibration line across rim
    let rimLine = null; // {x1,y1,x2,y2, n:(normal vector), dir:'down'}

    // Motion history for crossing detection
    const history = [];

    function speak(text){
      try{
        const u = new SpeechSynthesisUtterance(text);
        u.rate = 1.0; u.pitch = 1; u.volume = 1;
        speechSynthesis.cancel();
        speechSynthesis.speak(u);
      }catch(e){/* ignore */}
    }

    function showToast(){
      els.toast.classList.add('show');
      setTimeout(()=> els.toast.classList.remove('show'), 1200);
    }

    function setLive(on){
      els.liveDot.classList.toggle('live', on);
      els.liveDot.classList.toggle('idle', !on);
      els.liveText.textContent = on ? 'Detecting' : 'Idle';
    }

    async function startCam(){
      try{
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio:false });
        els.video.srcObject = stream;
        await els.video.play();

        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        running = true; detecting = false;
        els.btnDetect.disabled = false; els.btnStop.disabled = false; els.btnStart.disabled = true;
        loop();
      }catch(err){
        alert('Camera error: ' + err.message);
      }
    }

    function stopAll(){
      detecting = false; running = false; setLive(false);
      if(anim) cancelAnimationFrame(anim);
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
      els.btnStart.disabled = false;
      els.btnDetect.disabled = true; els.btnStop.disabled = true;
    }

    function resizeCanvases(){
      const vw = els.video.videoWidth || 1280;
      const vh = els.video.videoHeight || 720;
      els.overlay.width = vw; els.overlay.height = vh;
      work.width = Math.round(vw * SCALE);
      work.height = Math.round(vh * SCALE);
    }

    function drawLine(ctx, x1,y1,x2,y2, color = '#70e1ff'){
      ctx.save();
      ctx.lineWidth = 4; ctx.strokeStyle = color; ctx.setLineDash([8,6]);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    }

    function loop(){
      if(!running){ return; }
      anim = requestAnimationFrame(loop);

      if(els.video.readyState < 2) return;
      // draw overlay background (clear)
      octx.clearRect(0,0,els.overlay.width, els.overlay.height);

      // draw warning if not calibrated
      if(!rimLine){
        octx.save(); octx.fillStyle = 'rgba(255,255,255,.08)'; octx.font = '16px ui-sans-serif';
        octx.fillText('Tap "Calibrate rim line" and mark the rim edges', 16, 28);
        octx.restore();
      } else {
        drawLine(octx, rimLine.x1, rimLine.y1, rimLine.x2, rimLine.y2);
      }

      // Compute fps
      frames++;
      const now = performance.now();
      if(now - lastTime > 500){
        fpsAvg = Math.round( (frames * 1000) / (now - lastTime) );
        els.fps.textContent = fpsAvg; frames=0; lastTime = now;
      }

      if(!detecting) return;

      // PROCESS: frame differencing
      wctx.drawImage(els.video, 0,0, work.width, work.height);
      const curr = wctx.getImageData(0,0,work.width, work.height);

      // store/compare with previous frame
      if(!loop.prev){ loop.prev = wctx.getImageData(0,0,work.width, work.height); return; }
      const prev = loop.prev;

      let moved = 0, sumX=0, sumY=0;
      const dataC = curr.data, dataP = prev.data;
      // Binary mask & centroid
      for(let i=0;i<dataC.length;i+=4){
        const dr = dataC[i]-dataP[i];
        const dg = dataC[i+1]-dataP[i+1];
        const db = dataC[i+2]-dataP[i+2];
        const diff = Math.abs(dr)+Math.abs(dg)+Math.abs(db);
        if(diff > THRESH){
          const idx = i/4;
          const x = idx % work.width;
          const y = Math.floor(idx / work.width);
          moved++;
          sumX += x; sumY += y;
        }
      }
      // swap buffers
      loop.prev = curr;

      els.motion.textContent = moved;

      if(moved > MIN_AREA){
        const cx = (sumX / moved) / SCALE;
        const cy = (sumY / moved) / SCALE;
        // draw centroid
        octx.save();
        octx.fillStyle = '#45f0a0';
        octx.beginPath(); octx.arc(cx, cy, 8, 0, Math.PI*2); octx.fill();
        octx.restore();

        if(rimLine){
          // Compute which side of the line the centroid is on using line equation
          const side = pointSideOfLine(cx, cy, rimLine);
          history.push({t: now, side, y: cy});
          // Keep last 900ms
          while(history.length && now - history[0].t > 900) history.shift();

          // Detect crossing: must have points above then below, and net downward motion
          const hadAbove = history.some(h => h.side < 0);
          const hadBelow = history.some(h => h.side > 0);
          const recent = history[history.length-1];
          const first = history[0];
          const downward = (recent && first) ? (recent.y - first.y) > 20 : false;

          if(hadAbove && hadBelow && downward){
            // debounce: ensure we didn't just trigger
            if(!loop.lastTrigger || now - loop.lastTrigger > 1200){
              loop.lastTrigger = now;
              const n = parseInt(els.count.textContent,10)+1; els.count.textContent = n;
              setLive(true);
              showToast();
              speak('Nice shot');
              // reset history to avoid double fire
              history.length = 0;
            }
          }
        }
      } else {
        // push idle state to history occasionally to decay
        if(history.length && now - history[history.length-1].t > 200){
          history.push({t: now, side: 0, y: 0});
          while(history.length && now - history[0].t > 900) history.shift();
        }
      }
    }

    function pointSideOfLine(px,py, line){
      // Sign of cross product: (x2-x1, y2-y1) x (px-x1, py-y1)
      const s = (line.x2 - line.x1)*(py - line.y1) - (line.y2 - line.y1)*(px - line.x1);
      // Define negative as "above" (arbitrary) by projecting using normal
      return Math.sign(s);
    }

    // Calibration: tap two points across rim
    function startCalibration(){
      if(!els.video.videoWidth){ alert('Start camera first.'); return; }
      els.calibOverlay.classList.add('active');

      const points = [];
      function onTap(ev){
        const rect = els.overlay.getBoundingClientRect();
        const x = (ev.touches? ev.touches[0].clientX: ev.clientX) - rect.left;
        const y = (ev.touches? ev.touches[0].clientY: ev.clientY) - rect.top;
        points.push({x: x * (els.overlay.width/rect.width), y: y * (els.overlay.height/rect.height)});
        if(points.length === 2){
          els.calibOverlay.classList.remove('active');
          els.overlay.removeEventListener('click', onTap);
          els.overlay.removeEventListener('touchstart', onTap);
          rimLine = { x1: points[0].x, y1: points[0].y, x2: points[1].x, y2: points[1].y };
          // Visual feedback
          octx.clearRect(0,0,els.overlay.width, els.overlay.height);
          drawLine(octx, rimLine.x1, rimLine.y1, rimLine.x2, rimLine.y2, '#8fd1ff');
          els.btnDetect.disabled = false;
        }
      }
      els.overlay.addEventListener('click', onTap, { once:false });
      els.overlay.addEventListener('touchstart', onTap, { once:false, passive:true });
    }

    function startDetection(){
      if(!rimLine){ alert('Calibrate the rim line first.'); return; }
      detecting = true; setLive(true);
    }

    // UI events
    els.btnStart.addEventListener('click', startCam);
    els.btnStop.addEventListener('click', stopAll);
    els.btnCalib.addEventListener('click', startCalibration);
    els.btnDetect.addEventListener('click', startDetection);

    // iOS: lock orientation hint (optional)
    if(screen.orientation && screen.orientation.lock){
      screen.orientation.lock('portrait').catch(()=>{});
    }
  </script>
</body>
</html>

